{
    "collab_server" : "",
    "contents" : "#AIM of this script is to dissipate a Mw from a line\n#basic process is to define a circle of decreasing radius\n#Move the line with respect to the circle around the original line\n#This allows the formation of a line dissipating\nrequire(plyr)\nrequire(raster)\n\ncreate_matrix <- function(longdim,latdim,stepdist){\n  #create a matrix with the given data\n  lat_array = seq(latdim[1],latdim[2], by = stepdist)\n  long_array = seq(longdim[1],longdim[2], by = stepdist)\n  totalnumber = length(long_array)*length(lat_array)\n  matrix1 = matrix(data = c(rep(0,totalnumber)),ncol = length(long_array), byrow = FALSE)\n  colnames(matrix1) <- long_array\n  rownames(matrix1) <- lat_array\n  return(matrix1)\n}\n\ncreate_line <- function(matrix1,Mw,templong,templat,coordsx,coordsy){\n  #for the line situation use all points to offset\n\n  for (i2 in 1:length(coordsx)){\n    \n    #calculate the coordinates of the matrix\n    long2 <- round(as.numeric(coordsx[i2])+as.numeric(templong))\n    lat2 <- round(as.numeric(coordsy[i2])+as.numeric(templat))\n  \n    if(is.element(long2,as.numeric(colnames(matrix1))) & is.element(lat2,as.numeric(rownames(matrix1)))){\n      matrix1[toString(lat2),toString(long2)] = Mw\n\n    }else{\n      #print('out of bounds')\n      \n    }\n  }\n  return(matrix1)\n}\n\n\ncreate_ends <- function(matrix1,Mw,templong,templat,coordsx,coordsy){\n\n  \n  #for ends only need first and last point of line\n  for (i in 1:length(templong)){\n    \n    for (i2 in c(1,length(coordsx))){\n\n      long2 <- round(as.numeric(coordsx[i2])+as.numeric(templong[i]))\n      lat2 <- round(as.numeric(coordsy[i2])+as.numeric(templat[i]))\n      #print(paste(long2,lat2))\n      #Assign Mw to the calculated coordinates in the matrix\n      if(is.element(long2,as.numeric(colnames(matrix1))) & is.element(lat2,as.numeric(rownames(matrix1)))){\n        matrix1[toString(lat2),toString(long2)] = Mw\n\n      }else{\n        #print('out of bounds')\n        \n      }\n    }\n  }\n  plot(raster(matrix1))\n  #max(matrix1)\n  return(matrix1)\n}\n\n\ncreate.circle4 <- function(matrix1,Mw,distance,coordsx,coordsy){\n  #R <- distance\n  #treating like polar coordinates we need an angle and a distance\n  R <- distance\n  #to speed up the algorithm find the angle of the line\n  deltax <- coordsx[length(coordsx)] - coordsx[1]\n  deltay <- coordsy[length(coordsy)]- coordsy[1]\n  angle_line <- atan(deltay/deltax)\n  \n  #find the perpendicular angles to the line\n  angle_lineperp1 <- (angle_line + pi/2) %% (2*pi)\n  angle_lineperp2 <- (angle_line-pi/2) %% (2*pi)\n\n  precision = 32\n  #Using an excel file to understand a central cell is surrounded by 8 then 16,24 etc. as you go out a number of layers\n  templat <- vector(mode='numeric',length=precision*R)\n  templong <- vector(mode='numeric',length=precision*R)\n  for (i in 1:(precision*distance)){\n    \n    #split the angle so it matches the cells of the matrix\n    angle_templong <- i*(2*pi-2*pi/(precision*R))/(precision*R)\n    #determine the cell locations\n    templong[i] <- round_any(R*cos(angle_templong),1)\n    templat[i] <- round_any(R*sin(angle_templong),1)\n    matrix1 <- create_line(matrix1=matrix1,Mw = Mw,templong = templong[i],templat = templat[i],coordsx = coordsx,coordsy=coordsy)\n    #if the angle is close to the perp angle of line offset the line by the given distance\n    # if(abs((angle_templong - angle_lineperp1 + pi + 2*pi) %% (2*pi) - pi)< pi/(2*R)){\n    #   matrix1 <- create_line(matrix1=matrix1,Mw = Mw,templong = templong[i],templat = templat[i],coordsx = coordsx,coordsy=coordsy)\n    # \n    #   }else if(abs((angle_templong - angle_lineperp2 + pi + 2*pi) %% (2*pi) - pi) < pi/(2*R)){\n    #   matrix1 <- create_line(matrix1=matrix1,Mw = Mw,templong = templong[i],templat = templat[i],coordsx = coordsx,coordsy=coordsy)\n    # }\n\n  }\n  #now use the two end points of the line to create the end dissipation\n  #print(max(matrix1))\n  matrix1 <- create_ends(matrix1=matrix1,Mw = Mw,templong = templong,templat = templat,coordsx = coordsx,coordsy=coordsy)\n\n  \n  return(matrix1)\n}\ndissipate <- function(matrix1,Mw,coordsx,coordsy,longdim,latdim,degpersqr){\n#dissipate <- function(Mw,degpersqr){\n  #As a 4 on magnitude is not very significant dissipate until 4 is reached\n  Mw_dis <- Mw\n  \n  #We know the number of degrees per sqr of matrix so modify the distance to take account of dissipation\n   #1 degree equals c.110km\n   #******************************************\n  #Mw_dis = 8\n  \n  #CHANGED HERE!!\n  #dist = ( (10^( 1.5*(Mw_dis - 4) ) )/(2*pi))^(1/2.4)\n  dist = ( (10^( 1.5*(Mw_dis - 4) ) )/(2*pi))^(1/2.0)\n\n  distance <- round_any(dist/degpersqr/110,1)\n  print('distance')\n  print(distance)\n  print(Mw_dis)\n\n  #*****************************************\n  diss_per_sqr <- degpersqr\n\n  if(distance >0 ){\n    for (i in seq(1,distance,by=1)){\n      #********************************\n      kmdist = (distance - i)*degpersqr * 110\n      \n      \n      #Changed here as well!!!\n      #tempMw = Mw - log10(2 * pi * kmdist^2.4)/1.5\n      tempMw = Mw - log10(2 * pi * kmdist^2.0)/1.5\n\n      \n      if(!is.finite(tempMw)){\n        tempMw = Mw\n      }\n      #print(tempMw)\n      #tempMw = Mw - i*diss_per_sqr\n      #********************************\n      tempdist = 1+distance - i\n      #print(tempMw)\n      #write to the matrix using this Mw and distance\n      matrix1 <- create.circle4(matrix1,tempMw,tempdist,coordsx,coordsy)\n    }\n  }\n  print(Mw)\n  matrix1 <- create_line(matrix1=matrix1,Mw = Mw,templong = 0,templat = 0,coordsx = coordsx,coordsy=coordsy)\n  return(matrix1)\n}\n\n\n\n# Mw <- 6\n# degpersqr <- 0.04166667\n# dissipate(Mw,degpersqr)\n\n\n\n\n\n\ndissipate_FL_Mw <- function(Population_Data,coordsx,coordsy,Mw){\n  \n\n  \n  \n  #Mws here are replicated but come from a raster\n  longdim = c(Population_Data@bbox[1,1],Population_Data@bbox[1,2])\n  latdim = c(Population_Data@bbox[2,1],Population_Data@bbox[2,2])\n  #Population_Data@bbox\n  print(longdim)\n  print(latdim[1])\n  \n  degpersqr = Population_Data@grid@cellsize[2]\n  #Transfer the original coordinates into easier to use integers\n  norows <- (latdim[2] - latdim[1])/degpersqr\n  nocols <- (longdim[2] - longdim[1])/degpersqr\n  \n  #ADJUST COORDS TO BE MORE SENSITIVE AND COVER EVERY BIT OF MATRIX THE LINE IS ON\n  coordsxtemp <- c()\n  coordsytemp <- c()\n  \n  for (i in 1:(length(coordsx)-1)){\n    deltax1 <- abs(coordsx[i+1]-coordsx[i])\n    deltay1 <- abs(coordsy[i+1]-coordsy[i])\n    #print(paste(deltax1,deltay1))\n    if (deltax1 > deltay1){\n      if(degpersqr >abs(coordsy[i]-coordsy[i+1])){\n        len <- floor(abs(coordsx[i]-coordsx[i+1])/degpersqr) + 1\n        tempy <- rep(coordsy[i],length = len)\n      }else if(coordsy[i]>coordsy[i+1]){\n        tempy <- seq(coordsy[i],coordsy[i+1],by = -degpersqr*deltay1/deltax1)\n      }else{\n        tempy <- seq(coordsy[i],coordsy[i+1],by = degpersqr*deltay1/deltax1)\n      }\n      if(coordsx[i]>coordsx[i+1]){\n        tempx <- seq(coordsx[i],coordsx[i+1],-degpersqr)\n      }else{\n        tempx <- seq(coordsx[i],coordsx[i+1],degpersqr)\n      }\n\n    }else{\n      #print(coordsx[i])\n      #print(coordsx[i+1])\n      \n      if(coordsy[i]>coordsy[i+1]){\n        tempy <- seq(coordsy[i],coordsy[i+1],by = -degpersqr)\n      }else{\n        tempy <- seq(coordsy[i],coordsy[i+1],by = degpersqr)\n      }\n      \n      if(degpersqr >abs(coordsx[i]-coordsx[i+1])){\n        len <- floor(abs(coordsy[i]-coordsy[i+1])/degpersqr) + 1\n        tempx <- rep(coordsx[i],length = len)\n      }else if(coordsx[i]>coordsx[i+1]){\n        tempx <- seq(coordsx[i],coordsx[i+1],-degpersqr*deltax1/deltay1)\n      }else{\n        tempx <- seq(coordsx[i],coordsx[i+1],degpersqr*deltax1/deltay1)\n      }\n\n    }\n    coordsxtemp <- c(coordsxtemp, tempx)\n    coordsytemp <- c(coordsytemp, tempy)\n  }\n  coordsytemp = coordsytemp[is.finite(coordsxtemp)]\n  coordsxtemp = coordsxtemp[is.finite(coordsxtemp)]\n  coordsxtemp = coordsxtemp[is.finite(coordsytemp)]\n  coordsytemp = coordsytemp[is.finite(coordsytemp)]\n  plot(coordsxtemp,coordsytemp)\n  min(coordsx)\n  min(coordsxtemp)\n  #coordsx <- coordsxtemp\n  #coordsy <- coordsytemp\n  coordxbk <- coordsx\n  coordsybk <- coordsy\n  #min(coordsxtemp)\n  #min(coordsx)\n  \n  #df <- data.frame(coordsxtemp,coordsytemp)\n  #Map + geom_path(aes(x = coordsxtemp, y =coordsytemp),data = df)\n  coordsx <- round_any((coordsx - longdim[1])/degpersqr,1)\n  coordsy <- round_any((latdim[2] - coordsy)/degpersqr,1)\n  \n  print(max(coordsx))\n  print(max(coordsy))\n\n  latdim <- c(1,norows)\n  longdim <- c(1,nocols)\n  #create a matrix using these Mws\n  #Same dimensions as raster but from 1:... row and col names\n  matrix1 <- create_matrix(longdim,latdim,1)\n  as.matrix(Population_Data)\n  length(colnames(matrix1))\n  length(rownames(matrix1))\n  #Mw <- 6\n  #Initiate the function to dissipate from the line\n  matrix1 <- dissipate(matrix1,Mw,coordsx,coordsy,longdim,latdim,degpersqr)\n\n  #print(length(rownames(matrix1)))\n  #print(length(seq(Population_Data@bbox[2,1],Population_Data@bbox[2,2], by = degpersqr)))\n  rownames(matrix1) <- seq(Population_Data@bbox[2,1],Population_Data@bbox[2,2]-degpersqr, by = degpersqr)\n  colnames(matrix1) <- seq(Population_Data@bbox[1,1],Population_Data@bbox[1,2]-degpersqr, by = degpersqr)\n  print(max(matrix1))\n  return(matrix1)\n}\n# floor(10/3)\n# seq(1,11,by = 3)\n# abs(3-2)\n\n# # Population_Data@bbox\n# # Population_Data@bbox[2,1]\n# # \n# FL_Data4 <- FL_Data3[FL_Data3$lon>Population_Data@bbox[1,1],]\n# FL_Data4 <- FL_Data4[FL_Data4$lon<Population_Data@bbox[1,2],]\n# FL_Data4 <- FL_Data4[FL_Data4$lat>Population_Data@bbox[2,1],]\n# FL_Data4 <- FL_Data4[FL_Data4$lat<Population_Data@bbox[2,2],]\n# unique(FL_Data4$id)\n# \n#tempFL_Data <- FL_Data3[FL_Data3$id == 61,]\n# coordsx <- tempFL_Data[,'lon']\n# coordsy <- tempFL_Data[,'lat']\n# #\n#coordsx <- c(28,29,29.5,30)\n#coordsy <- c(37,39,39,40)\n# length(coordsx)\n# length(coordsy)\n# plot(coordsx,coordsy)\n# #Mw <- tempFL_Data[1,'Mw']\n#Mw <- 5\n# # rm(long2)\n# # rm(lat2)\n#matrix <- dissipate_FL_Mw(Population_Data,coordsx,coordsy,Mw)\n# \n# max(matrix)\n# \n# plot(raster(matrix))\n# coordsx2 <- coordsx\n# coordsy2 <- coordsy\n# coordsy\n# matrix1 <- matrix\n# max(matrix1)\n# rstr <- raster(matrix1)\n# rstr2 <- data.frame(matrix1)\n# Mw33 <- asc.from.raster(rstr)\n# Mw.sp1 <- sp.from.asc(Mw33)\n# Mw.sp2 <- spTransform(Mw.sp1,CRS(as.character(\"+init=epsg:3857\")))\n# #Mw.sp1 <- Mw.sp2\n# plot(Mw.sp1)\n# \n# class(Mw.sp1)\n# Mw.sp2 <- Mw.sp1[Mw.sp1@data$z > 0,]\n# \n# \n# \n# rstr2 <- data.frame(Mw.sp2)\n# rstr2$s1 <- rstr2$s1 * 32\n# rstr2$s2 <- rstr2$s2 * 40\n# \n# \n# plot(rstr)\n# #df <- data.frame(coordsx,coordsy)\n# x <- ggplot(data = df) + geom_path(aes(x = coordsx, y =coordsy),data = df)\n# x + geom_point(aes(x = s1, y = s2,fill = z),data = rstr2)\n\n# \n# rm(coordsx)\n# rm(coordsy)\n\n#load('NA_FAULT.RData')\n#load('NA_FAULT2.RData')\n",
    "created" : 1491118748267.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "163925333",
    "id" : "EBBDA1F5",
    "lastKnownWriteTime" : 1491118883,
    "last_content_update" : 1491118883645,
    "path" : "~/Earthquake_v4/Earthquake_v4/ALL_FUNCTIONS/03_02_Data_Dissipate_FL_Matrix_TESTING_v5.R",
    "project_path" : "ALL_FUNCTIONS/03_02_Data_Dissipate_FL_Matrix_TESTING_v5.R",
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}